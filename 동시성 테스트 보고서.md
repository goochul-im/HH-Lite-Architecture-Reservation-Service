# 동시성 테스트 보고서

## 중복 예약
현재 여러 스레드가 동시에 같은 자리에 예약했을 경우, 락이나 유니크 제약조건이 없기에 중복예약이 발생
- 이 프로젝트의 경우 각 자리 하나하나가 DB에서 관리되지는 않음
- 모든 날짜에 콘서트 하나가 있고, 각 콘서트마다 1~50 번의 자리가 있음으로 간주되고 있음
- 따라서 Seat 엔티티를 조회하고 수정하는 락을 걸 수 없음

### 중복 예약 발생 시나리오
- kotlin/kr/hhplus/be/server/reservation/service/ReservationService.kt
위 클래스의 make() 함수에서 발생
```kotlin
if (!getAvailableSeat(dto.date).contains(dto.seatNumber)) {
    throw DuplicateResourceException("이미 예약되어있는 좌석입니다.")
}
```
- make()함수는 getAvailableSeat() 를 통해 날짜와 자리 번호를 받아 현재 DB와 Redis에 있는지 확인함
- A가 10번 자리를 예약하려고 들어왔을 때 위 검사를 통과함
- 그 순간 B도 10번 자리를 예약했을 때, 아직 DB나 Redis에 저장이 안되어있기에 위 검사를 통과
```kotlin
val save : Reservation = reservationRepository.save(reservation)
```
- 이후 그대로 A가 10번 자리를 예약해서 DB에 저장
- B도 같이 10번 자리를 예약해서 DB에 저장
- 중복 예약 발생

### 해결 전략
- 락으로 해결할 수 없음
- 유니크 제약조건을 걸어 같은 날짜의 같은 자리가 [PENDING, RESERVE] 로 존재하지 않도록 해야함
- 하지만 JPA에서 복잡한 인덱스를 걸 수 없음
- 따라서 DB에 직접 다음 인덱스 지정
```sql
CREATE UNIQUE INDEX uk_active_reservation ON reservation (reservation_date, seat_num,
(CASE WHEN reservation_status in ('RESERVE', 'PENDING') THEN reservation_status ELSE NULL END));
```
- 이후 make() 쪽에서 try 설정
```kotlin
val save : Reservation = try {
    reservationRepository.save(reservation)
} catch (e: DataIntegrityViolationException) {
    throw DuplicateResourceException("이미 예약되어있는 좌석입니다.")
}
```

### 테스트
- src/test/java/kr/hhplus/be/server/concurrency/ReservationConcurrencyTest.kt
- 스레드 30개를 만들어 하나의 자리에 동시에 예약하도록 작성
- 단 1개의 요청만 성공하여 테스트 완료
- 현재 테스트 전용으로 쓰이는 DB가 있으므로 여기서도 전용 sql 파일 필요 (src/test/resources/test-index-setup.sql)

### 개선해야 할 점
- 프로젝트를 처음부터 잘못 설계했나 싶음
- Seat 엔티티가 있으면 락을 걸수 있었을 듯
- 테스트에서는 테스트 전용 DB를 사용하므로 인덱스를 걸어주는 sql을 또 사용해야하는 번거로움이 있었음

---
## 중복 결제
현재 여러 스레드가 같은 자리에 동시에 결제를 요청하는 경우 발생 가능 (예를 들어 결제 버튼 따닥)
- 중복 결제가 발생하는 지점 kotlin/kr/hhplus/be/server/reservation/service/ReservationService.kt 의 payReservation()

### 중복 결제 발생 시나리오
- payReservation() 함수는 예약 id와 유저 id를 받아 결제를 진행함
```kotlin
var reserver = memberRepository.findById(userId)
var reservation =
    reservationRepository.findReservationByIdAndReserver(reservationId, reserver.id!!)
if (reservation.status != ReservationStatus.PENDING) {
    throw RuntimeException("예약한 자리가 아닙니다.")
}
```
- 이 코드에서 유저와 예약자리를 찾고 유효성 검사를 함
- A 스레드가 위 검사를 통과
- 그 순간 B 스레드도 위 검사를 통과
```kotlin
reserver.usePoint(price)
reserver = memberRepository.save(reserver)
```
- 이후 A 스레드에서 위 코드를 거쳐 포인트를 차감하고, 결제 완료
- B 스레드에서도 결제 완료, 중복 결제 발생

### 해결 전략
- MemberEntity에 낙관적 락 적용
```kotlin
class MemberEntity
@Version
var version: Long = 0
```
- Member 도메인 클래스에도 같은 필드를 추가해야함
```kotlin
class Member
val version: Long = 0
```
- 하지만 JPA는 쓰기 지연 저장소를 사용하기 때문에 즉시 중복 결제를 감지할 수 없음
- 따라서 쓰기 지연이 아닌 곧바로 변경 사항을 DB에 flush 해야함
```kotlin
override fun saveAndFlush(member: Member): Member {
    val entity = MemberEntity.from(member)
    val domain = memberJpaRepository.save(entity).toDomain()
    memberJpaRepository.flush()
    return domain
}
```
- 이후 이를 감지하여 예외를 발생
```kotlin
try {
    reserver = memberRepository.saveAndFlush(reserver)
} catch (e: ObjectOptimisticLockingFailureException) {
    throw DuplicateResourceException("이미 결제된 자리입니다. ${e.message}")
}
```

### 테스트
- src/test/java/kr/hhplus/be/server/concurrency/ReservationConcurrencyTest.kt
- 5개의 스레드를 만들어 중복 결제 테스트
- 단 1개의 결제 요청만 성공하여 테스트 완료

### 의문점
- Member 도메인에 version 필드가 생성되어 도메인 순수성이 깨진 듯함
- 이러면 도메인 영역이 JPA를 알게 되는 것이 아닌가? 싶음
---
## 예약 후 결제 지연
- src/test/java/kr/hhplus/be/server/reservation/service/RedisReservationOperationsImplTest.kt 에 테스트 만들어둠
- Redis의 TTL을 이용하였으므로 문제없을 것으로 예상됨
