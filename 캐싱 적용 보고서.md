# 캐싱 적용 보고서

## 환경
- Spring boot 3.4.1
- JDK 17
- Redis Cache 사용
- Mysql 사용
- localhost
- Jmeter
- 사용한 Jmeter Plan : https://drive.google.com/file/d/1XJuTfPHMgvS54Jf3ytrA3CbT5lL9T7e5/view?usp=sharing

## 테스트 스펙
- Intel Core Ultra 5 125H
  - 3.60Ghz
- Memory 32GB
- Tomcat
  - max threads 200
  - min threads 10

## 테스트 설정
- 스레드 100 개
- 요청 30번 (GET /api/reservation/date/{date})

## 캐싱 시나리오
- 현재 예약되어있지 않은 좌석 정보
- kotlin/kr/hhplus/be/server/reservation/service/ReservationService.kt
  - getAvailableSeat 메소드에서 캐싱

### 문제 상황
- getAvailableSeat 메소드는 현재 사용가능한 좌석 정보를 가져오는 역할을 함
  - RDB와 Redis를 동시에 조회
- (GET /api/reservation/date/{date}) 에서 예약 가능한 좌석 정보를 가져올 때 사용
- 더해서 ReservationService의 make 메소드에서도 예약 전에 좌석이 사용 가능한지 검사할 때 사용

## 코드
- RedisConfig에 캐시 매니저 등록
- ReservationService의 getAvailableSeat에 @Cacheable 설정
  - ```kotlin
    @Cacheable(value = ["availableSeats"], key = "#date.toString()")
    ```
- 하지만 예약 가능 좌석은 임시 예약이 만들어질 때나 예약 취소가 될 때 업데이트가 필요함 
    - 캐시 업데이트를 위해 같은 클래스의 make에는 @CacheEvict 설정
  - ```kotlin
      @CacheEvict(value = ["availableSeats"], key = "#dto.date.toString()")
      ```
  - TempReservationService의 cleanupExpiredReservation에서는 date를 직접적으로 가져올수 없으므로, 캐시매니저를 주입받아 직접 삭제
    - ```kotlin
      cacheManager.getCache("availableSeats")?.evict(reservation.date.toString())
      ```

## 측정 결과
캐시 적용 시에는 cold start 까지 고려
### 캐싱 적용 전
- Min : 42ms
- Average : 374ms
- Max : 948ms
- Throughput : 236.5/sec
### 캐싱 적용 후
- Min : 13ms
- Average : 288ms
- Max : 814ms
- Throughput : 324.0/sec
### 분석
- 최소 응답 속도 약 70% 단축
- 초당 처리량 37% 향상
- 평균 시간은 크게 개선되지 않음. 이는 각 스레드마다 토큰 검증 시간이 대부분의 오버헤드를 차지하고 있는 것으로 추정됨
- Max 시간은 cold start 때문에 캐싱 적용 전과 비슷한 것으로 추정

## 결론
- 만약 특정 콘서트 날짜에 트래픽이 대량으로 발생한다면 Cache Evict가 빈번하게 발생할 것이므로 유효한 전략인지 의문임
- 현재의 웹 애플리케이션에서 캐시를 적절하게 사용할 부분을 찾기가 힘듬
  - 조회는 포인트, 예약 가능 날짜 등 밖에 존재하지 않음
  - 자주 사용되지만 잘 바뀌지 않는 데이터를 찾지 못함
